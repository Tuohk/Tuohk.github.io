[{"title":"Hello World","url":"/2021/02/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"原型和原型链到底是什么东西","url":"/2021/03/02/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/","content":""},{"title":"数据类型","url":"/2021/03/01/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"JavaScript中什么是基本数据类型什么是引用类型？以及各个数据类型是如何存储的？基本数据类型有：U ARE SO NBU(undefined) S(string symbol) N(null number) B(boolean BigInt)引用类型统称为Object类型细分的话有：Object,array,date,RegExp,Function基本数据类型的数据直接存储在栈中，而引用数据类型是存储在堆中,每个对象在栈地址都会有一个引用地址，引用类型在栈空间都会保存自己的引用地址，以便快速找到堆内存中的对象。栈内存是自动分配内存的。而堆内存是动态分配内存的，不会自动释放，所以每次使用完对象的时候都要将它设置为NULL ,从而减少无用内存的消耗\n\n类型转换在JavaScript中为什么0.2+0.1&gt;0.3?因为在JavaScript中，浮点数是由64位固定长度来表示的，其中1位表示符号位，11位表示指数位，剩下的52位表示尾数位，由于只有52位尾数位，而0.1转为二进制时是0.0001100110011001100…（1100循环）\n\n十进制转二进制方法：这里插入一个地址谢谢！！！由于只能存储52位尾数位，所以便存在精度缺失，把它从内存中取出来转换成十进制就不是原来的0.1了，变成0.10000000…555111。而0.2+0.1是因为0.2和0.1都转换为二进制进行计算，转换为十进制正好是0.30000…004\n\n这时候面试官又会说了 那为什么0.2+0.3=0.5捏？？？嗯？因为0.2和0.3先转化为二进制进行计算，结果是0.10000…001 这时候1的尾数是大于52位，而实际数取值是取52位尾数位的！因此截取后便是0.5\n\n这时候面试官还是那么可爱 又问既然0.1不是0.1了!那为什么输出console.log(0.1)的时候还是0.1呢？这里其实我也不懂,正确答案：在console.log的时候会二进制转换为十进制，十进制会转换为字符串形式，在转换过程中会取近似值，所以打印出来的是一个近似值的字符串！哦耶~\n\n判断数据类型有几种方法？//四种最常用的判断方法：typeof\n缺点：typeof null的值为object 无法分辨是null还是object\n\n\n判断已知对象的方法：instanceof\n缺点：无法判断对象是否存在自己的原型链上\n\n\n根据对象的construct判断：注意：construct在类继承时会出错\n\n\n通用但很繁琐的方法：object.prototype.toString.call()\n\n\n\ninstanceof原理instanceof就是查找目标对象的原型链\n\n为什么typeof null是object这其实是个BUG，因为在JavaScript中，不同对象都是用二进制存储的，如果二进制前三位数为0的话，系统会判断为object类型，而null的前三位数刚好是0，所以也变成了object类型\n\n==  和 ===  有什么区别？===是严格意义上的相等，会比较数据类型和值大小数据类型不同，返回flase数据类型相同，但值大小不同，返回flase\n==是非严格意义上的相等，会比较值的大小数据类型相同，比较值大小数据类型不同，会根据以下表格，再进一步比较。\n    Null == undefined -&gt; true\n    String == Number -&gt; 先将String转换为Number，再比较大小\n    Boolean == Number -&gt; 先将Boolean转换为Number，再比较大小\n    Object == String,Number,Symbol -&gt; Object转换为原始类型\n\n\n手写call，apply，bind本宝宝暂时不会，过两天学完来补上嘻嘻嘻🤭\n字面量创建对象和new创建对象有什么区别，new内部都实现了什么，手写一个new字面量：字面量创建对象更简单，方便阅读不需要作用解析，速度更快\n    let person = &#123;\n        name : &#39;小宇子&#39;,\n        age : &#39;21&#39;,\n        loc : &#39;汕头&#39;,\n        skill : function()&#123;\n            alert(&#39;唱跳RAP&#39;);\n        &#125;\n    &#125;\n    console.log(function.skill());\n\nnew创建对象：创建一个new对象不懂了回去补知识。。。！！！\n\n","tags":["JavaScript"]},{"title":"计算机网络","url":"/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"三次握手四次挥手，为什么是三次握手而不是二次握手？客户端与服务端之间通过三次握手建立连接，四次挥手释放连接所谓的三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送三个包\n三次握手原理：(1)发送端首先发送一个带有SYN(synchronize)标志的数据包给接收方(2)接收方接收后，回传一个SYN/ACK标志的数据包给发送方传递信息，表示已接收(3)发送端收到接收方回传的数据包，会再次发送一个带有ACK标志的包进行确认，表示’握手’接收三次握手的目的是连接服务器指定端口，建立TCP连接并同步连接双方的序列号和确认号并交换TCP窗口大小信息\n之所以是三次握手，是因为如果只有二次握手，在服务端收到SYN后，便向客户端返回一个ACK确认就进行establish状态，万一这个请求中间出现了网络问题没有发送给客户端，客户端一直处于等待状态，导致后面的信息无法正常接收。\n四次挥手原理：改天再说，暂时不懂😄\n\nHTTP的结构"}]