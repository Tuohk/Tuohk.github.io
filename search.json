[{"title":"HTML入门笔记","url":"/2021/03/02/HTML%E5%85%A5%E9%97%A8/","content":"HTML是李爵士发明的\nHTML起手应该写标签\nHTML的章节标签表示文章/书签标题h1~h6                            \n章节section\n文章article\n段落p\n头部header\n脚部footer\n主要内容main\n旁支内容aside\n划分div\n全局属性class\ncontenteditable\nhidden\nid\nstyle\ntabindex\ntitle\n内容标签ol+li\nul+li\ndl+dt+dd\npre\nhr\na\nem\nstrong\ncode\nquote\nblockquote\n"},{"title":"CSS小结","url":"/2021/04/25/CSS%E5%B0%8F%E7%BB%93/","content":"CSS定位布局是屏幕平面上的，定位是垂直于屏幕的\n\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/position position参考\n"},{"title":"Git基本操作","url":"/2021/05/02/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"输入：git init （在当前文件夹下初始化一个git仓库）\n输入：git add . （将当前工作区的所有文件存放到暂存区）\n输入：git commit -m “描述信息”\n输入：git remote add origin https://github.com/...您的地址\n输入：git push -u origin main\ngit add README.md（可选）\n"},{"title":"JavaScript中的箭头函数","url":"/2021/04/27/JavaScript%E4%B8%AD%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","content":"JavaScript中 的箭头函数箭头函数没有arguments和this\n"},{"title":"HTTP缓存的意义","url":"/2021/04/25/HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89/","content":"HTTP缓存的意义https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching 原文链接\n通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用HTTP缓存，变得更加响应性。\n不同种类的缓存缓存的种类有很多，大致分为两类：私有与共享缓存。共存缓存存储的响应能被多个用户使用。私有缓存只能用于单独用户。\n私有（浏览器缓存）共享（代理缓存）缓存操作的目标常见的HTTP缓存只能存储”GET”响应\n成功响应状态码：200 一个成功获取HTML文档，图片，或者文件的响应。\n永久重定向状态码：301\n错误响应状态码：404\n不完全响应状态码：206（只返回局部的信息）\n缓存控制（Cache-control头）没有缓存Cache-Control: no-store\n\n缓存但重新验证Cache-Control: no-cache\n\n私有和公共缓存Cache-Control: private\nCache-Control: public\n\n过期Cache-Control: max-age=31536000\n\n验证方式Cache-Control: must-revalidate\n\nPragma头Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。\n"},{"title":"JavaScript基本语法","url":"/2021/04/06/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"JavaScript的基本语法:sun_with_face:1.什么是表达式和语句二者区别：\n1.表达式一般有值，语句可能有也可能没有2.语句一般会改变环境（声明，赋值）3.:point_up: 上面非绝对:point_up:2.标识符的规则所谓标识符，就是变量，函数，属性或函数参数的名称。标识符可以由一个或多个下列字符组成：第一个字符必须是字母，下划线（_），或美元符号（$）；\n剩下的其他字符可以是字母，下划线，美元符号或数字。\n标识符的字母可以是扩展ASCII中的字母，也可以是Unicode的字母字符。\n3.if else语句if (condition) statement1 else statement2 \n\n如果条件求值为 true，则执行语句 statement1；如果条件求值为 false，则执行语句 statement2。\n4.while for语句while语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此,while循环体内的代码有可能不会执行。for语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式5.break coutinuebreak和coutine语句为执行循环代码提供了更加严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而continue语句也用于立即退出循环，但会再次从循环顶部开始执行6.label（标签语句）标签语句用于给语句加标签，语法如下：label: statement\n\n下面是一个例子： start:  for (let i = 0; i &lt; count; i++)&#123;\n console.log(i)\n\n}\n在这个例子中,start是一个标签，可以在后面通过break或continue语句引用。标签语句典型应用场景是嵌套循环"},{"title":"JavaScript执行时机😁","url":"/2021/04/11/JavaScript%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/","content":""},{"title":"Vue中set的作用","url":"/2021/04/27/Vue%E4%B8%ADset%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"Vue中set的作用Vue.set 和 this.$set\n作用：新增key\n不会自动创建代理和监听\n触发UI更新（但不会立即更新）\n"},{"title":"Vue全解（1）","url":"/2021/04/27/Vue%E5%85%A8%E8%A7%A3%EF%BC%881%EF%BC%89/","content":"Vue全解（1）options的五类属性数据：data, props, propsData, computed, methods, watch\nDOM: el, template, render, renderError\n生命周期钩子: beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, destroyed, errorCaptured.\n资源: directives, filters, components\n组合: parent, mixins, extends, provide, inject\n其他: 先不看。\n"},{"title":"Vue文档小记之实例","url":"/2021/04/27/Vue%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AE%B0%E4%B9%8B%E5%AE%9E%E4%BE%8B/","content":"Vue文档小记之实例:upside_down_face:声明式渲染v-bind arrtribute被称为指令。指令前带有前缀v-。\n指令意思：将这个元素的节点的attribute和Vue实例 property保持一致\n组件化应用构建父传子用prop组件\n数据与方法// 我们的数据对象\nvar data = &#123; a: 1 &#125;\n\n// 该对象被加入到一个 Vue 实例中\nvar vm = new Vue(&#123;\n  data: data\n&#125;)\n\n// 获得这个实例上的 property\n// 返回源数据中对应的字段\nvm.a == data.a // =&gt; true\n\n// 设置 property 也会影响到原始数据\nvm.a = 2\ndata.a // =&gt; 2\n\n// ……反之亦然\ndata.a = 3\nvm.a // =&gt; 3\n\n这些数据改变时，视图也会被重新渲染，只有当实例被创建时已经存在于data中的property才是响应式。\nvm.b = &#39;hi&#39; //此时data没有b属性，无法渲染\n\n使用Object.freeze()可阻止修改现有的property\n"},{"title":"Vue生命周期图","url":"/2021/04/26/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE/","content":"英文中文\n"},{"title":"webpack中 loader和plugin的区别","url":"/2021/04/25/webpack%E4%B8%AD%20loader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"webpack中 loader和plugin的区别\nloader 加载器 用来加载文件 加载JS/CSS/IMG 文件\nplugin 插件 用来扩展功能   加强webpack功能 HtmlWebpackPlugin用来生成一个HTML文件     MiniCssExtractPlugin 用来抽取CSS文件生成一个文件\n"},{"title":"什么是MVVM模式？","url":"/2021/05/02/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%E6%A8%A1%E5%BC%8F%EF%BC%9F/","content":"什么是MVVM模式？字面意思：MVVM  Model-View-ViewModel\n一句话总结 Web 前端 MVVM：操作数据，就是操作视图，就是操作 DOM（所以无须操作 DOM ）。MVVM，说到底还是一种分层架构。它的分层如下：\n\nModel: 域模型，用于持久化\nView: 作为视图模板存在\nViewModel: 作为视图的模型，为视图服务\n\n\nModel 层它主要做域模型的同步Model 层，对应数据层的域模型，\n通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。\nView 层View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。View 层，作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，\nViewModel 层ViewModel 层把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。\n\n\n"},{"title":"关于DOM🥱","url":"/2021/04/12/%E5%85%B3%E4%BA%8EDOM/","content":"获取特定元素document.documentElement\n\n获取head元素document.head\n\n获取body元素document.body\n\n获取窗口（窗口不是元素）window\n\n获取所有元素document.all\n\nProperty vs Atteibuteproperty属性JS线程中div1的所有属性，叫做div1的property\nattribute也是属性渲染引擎中div1对应标签的属性，叫做attribute\n区别：大部分时候，同名的property和attribute值相等\n但如果不是标准属性，那么它两只会在一开始时相等\n但注意attribute只支持字符串\n而property支持字符串，布尔等类型\nDOM的增删改查删旧：parentNode.childChile(chileNode)\n新：chileNode.remove()\n改改class: div.className = ‘red blue’(全覆盖)\n改class: div.classList.add(‘red’)\n改style: div.style = ‘width: 100px; color:blue;’\n改style的一部分: div.style.width = ‘200px’\n​            大小写：div.style.backgroundColor=’white’\n改data-*属性：div.dataset.x = ‘frank’\n"},{"title":"什么是VUE响应式原理？","url":"/2021/04/27/%E4%BB%80%E4%B9%88%E6%98%AFVUE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9F/","content":"什么是VUE响应式原理？字面理解响应式：当数据变化时页面也会改变;实现原理：VUE在组件和实例初始化时，会对data里的数据进行数据劫持(Object.defineProperty),数据劫持后会有两个属性：一个是getter，一个是setter;getter是使用数据的触发，setter是修改数据的触发。修改数据触发setter，并触发底层的watcher监听，通知DOM进行修改"},{"title":"关于HTML盒模型","url":"/2021/04/25/%E5%85%B3%E4%BA%8EHTML%E7%9B%92%E6%A8%A1%E5%9E%8B/","content":"CSS的盒模型分两种，一种content盒模型   一种是border盒模型\ncontent 的宽度只包含content内容\nborder的宽度包含border padding content\nCSS调试时可使用border 也可使用outline outline不计边框元素\n"},{"title":"关于Vue中的父传子","url":"/2021/04/27/%E5%85%B3%E4%BA%8EVue%E4%B8%AD%E7%9A%84%E7%88%B6%E4%BC%A0%E5%AD%90/","content":"关于Vue中的父传子App.vue页面\n1.创建子组件，例如：Demo.vue(名字随意，好记就行)2.Demo.vue中创建props,并建立一个名为message的属性\n3.在App.vue中导入Demo组件，并在template中加入标签\n"},{"title":"关于WWW","url":"/2021/04/28/%E5%85%B3%E4%BA%8EWWW/","content":"关于WWWwww.xiedaima.com 和 xiedaima.com 是同一个域名吗？不是\ncom是顶级域名\nxiedaima.com是二级域名（俗称一级域名）\nwww.xiedaima.com是三级域名（俗称二级域名）\nwww可以说是多余的 只是为了适应用户使用习惯\n"},{"title":"原型和原型链到底是什么东西","url":"/2021/03/02/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/","content":""},{"title":"图解HTTP——第四章  返回结果的HTTP状态码笔记","url":"/2021/03/28/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%20%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AC%94%E8%AE%B0/","content":"3.6 内容协商返回最合适的内容内容协商机制是指客户端和服务器端就响应的资源进行协商，提供给客户端最适合的资源\n以响应资源的语音，字符集，编码方式作为判断的基准\n内容协商有三种技术：\n1.服务器驱动协商\n2.客户端驱动协商\n3.透明协商\n4.1 状态码告知从服务器端返回的请求结果1XX 信息性状态码 接受的请求正在处理\n2XX 成功状态码 请求正常处理完毕\n3XX 重定向状态码 需要附加操作以完成请求\n4XX 客户端错误状态码 服务器无法处理请求\n5XX 服务器错误状态码 服务器处理请求出错\n4.2 2XX 成功2XX 的响应结果表明请求被正常处理\n4.2.1 200 OK表示客户端发来的请求被服务器端正常处理\n4.2.2 204 No Content表示客户端发来的请求被服务器正常处理，但是请求无资源返回\n4.2.3 206 Partial Content表示客户端进行了范围请求，服务器端正常处理了这部分的 GET 请求\n4.3 3XX 重定向3XX 的响应结果表明浏览器需要执行某些特殊的处理来正确处理请求\n4.3.1 301 Move Permanently永久性重定向\n4.3.2 302临时重定向\n4.3.3 303 See other"},{"title":"对象增删改查小记😋","url":"/2021/04/07/%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%B0%8F%E8%AE%B0/","content":"JavaScript 对象基本用法对象删除属性delete obj.xxx 或 delete obj[&#39;xxx&#39;]\n\n//即可删除obj的xxx属性 请区分属性值为Undefined和不含属性名\n\n&#39;xxx&#39; in obj === false\n//不含属性名\n\n&#39;XXX&#39; in obj &amp;&amp; obj.XXX === undefined\n//含有属性名，但是值为undefined\n\nobj.xxx === undefined\n//不能断定&#39;xxx&#39; 是否为obj的属性\n\n查询Object.keys(obj)\nconsole.dir(obj)\nobj[&#39;name&#39;]\nobj.name //记住这里的name是字符串\nobj[name] //记住这里的name是变量\n\n改obj[&#39;name&#39;] = &#39;jack&#39; //改自身\nObject.assign(obj,&#123;age:18,...&#125;) //批量改自身\nobj._proto_[&#39;toString&#39;] = &#39;xxx&#39; //改共有属性 不推荐\nObject.prototype[&#39;toString&#39;] = &#39;xxx&#39; //改共有属性\nobj._proto_ = common    //改原型 不推荐\nlet obj = Object.create(common) //改原型\nps:所有的__proto__代码都是强烈不推荐写的\n\n增var obj1 = Object.create(&#123;name : &#39;frank&#39;&#125;) //属性添加在新的原型上\nvar obj2 = new Object(&#123;name : &#39;frank&#39;&#125;) //属性在自身上\n\n"},{"title":"数据类型","url":"/2021/03/01/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"JavaScript中什么是基本数据类型什么是引用类型？以及各个数据类型是如何存储的？基本数据类型有：U ARE SO NBU(undefined) S(string symbol) N(null number) B(boolean BigInt)引用类型统称为Object类型细分的话有：Object,array,date,RegExp,Function基本数据类型的数据直接存储在栈中，而引用数据类型是存储在堆中,每个对象在栈地址都会有一个引用地址，引用类型在栈空间都会保存自己的引用地址，以便快速找到堆内存中的对象。栈内存是自动分配内存的。而堆内存是动态分配内存的，不会自动释放，所以每次使用完对象的时候都要将它设置为NULL ,从而减少无用内存的消耗\n\n类型转换在JavaScript中为什么0.2+0.1&gt;0.3?因为在JavaScript中，浮点数是由64位固定长度来表示的，其中1位表示符号位，11位表示指数位，剩下的52位表示尾数位，由于只有52位尾数位，而0.1转为二进制时是0.0001100110011001100…（1100循环）\n\n十进制转二进制方法：这里插入一个地址谢谢！！！由于只能存储52位尾数位，所以便存在精度缺失，把它从内存中取出来转换成十进制就不是原来的0.1了，变成0.10000000…555111。而0.2+0.1是因为0.2和0.1都转换为二进制进行计算，转换为十进制正好是0.30000…004\n\n这时候面试官又会说了 那为什么0.2+0.3=0.5捏？？？嗯？因为0.2和0.3先转化为二进制进行计算，结果是0.10000…001 这时候1的尾数是大于52位，而实际数取值是取52位尾数位的！因此截取后便是0.5\n\n这时候面试官还是那么可爱 又问既然0.1不是0.1了!那为什么输出console.log(0.1)的时候还是0.1呢？这里其实我也不懂,正确答案：在console.log的时候会二进制转换为十进制，十进制会转换为字符串形式，在转换过程中会取近似值，所以打印出来的是一个近似值的字符串！哦耶~\n\n判断数据类型有几种方法？//四种最常用的判断方法：typeof\n缺点：typeof null的值为object 无法分辨是null还是object\n\n\n判断已知对象的方法：instanceof\n缺点：无法判断对象是否存在自己的原型链上\n\n\n根据对象的construct判断：注意：construct在类继承时会出错\n\n\n通用但很繁琐的方法：object.prototype.toString.call()\n\n\n\ninstanceof原理instanceof就是查找目标对象的原型链\n\n为什么typeof null是object这其实是个BUG，因为在JavaScript中，不同对象都是用二进制存储的，如果二进制前三位数为0的话，系统会判断为object类型，而null的前三位数刚好是0，所以也变成了object类型\n\n==  和 ===  有什么区别？===是严格意义上的相等，会比较数据类型和值大小数据类型不同，返回flase数据类型相同，但值大小不同，返回flase\n==是非严格意义上的相等，会比较值的大小数据类型相同，比较值大小数据类型不同，会根据以下表格，再进一步比较。\n    Null == undefined -&gt; true\n    String == Number -&gt; 先将String转换为Number，再比较大小\n    Boolean == Number -&gt; 先将Boolean转换为Number，再比较大小\n    Object == String,Number,Symbol -&gt; Object转换为原始类型\n\n\n手写call，apply，bind本宝宝暂时不会，过两天学完来补上嘻嘻嘻🤭\n字面量创建对象和new创建对象有什么区别，new内部都实现了什么，手写一个new字面量：字面量创建对象更简单，方便阅读不需要作用解析，速度更快\n    let person = &#123;\n        name : &#39;小宇子&#39;,\n        age : &#39;21&#39;,\n        loc : &#39;汕头&#39;,\n        skill : function()&#123;\n            alert(&#39;唱跳RAP&#39;);\n        &#125;\n    &#125;\n    console.log(function.skill());\n\nnew创建对象：创建一个new对象不懂了回去补知识。。。！！！\n\n","tags":["JavaScript"]},{"title":"数据类型小记😁","url":"/2021/04/07/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%8F%E8%AE%B0/","content":"变量声明三种声明方式\nvar a = 1;\nlet a = 1;\nconst a = 1;\na = 1; //错误形式\n\n区别 var 过时 const 声明后必须赋值,且不能修改, 最后声明方式为错误形式\nvar 有变量提升\nname 和 ‘name’的区别一个是变量 一个是字符串\n类型转换number =&gt; string\nString(n)\nn + &#39;&#39;\n&#39;&#39; + n\n\nstring =&gt; number\nNumbers(s)\nparseInt(s) / parseFloat(s)\ns - 0\n\nX =&gt; bool\nBoolean(x)\n!!X\n\nX =&gt; string\nString(x)\nx.toString(x)\n\n\n"},{"title":"浅析URL和输入URL会发生什么","url":"/2021/04/28/%E6%B5%85%E6%9E%90URL%E5%92%8C%E8%BE%93%E5%85%A5URL%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/","content":"浅析URL\nUniform Resource Locator（URL）统一资源定位符URL包含以下基本部分：以https://zh.wikipedia.org:443/w/index.php?title=Special:随机页面为例, 其中：\n\nhttps，是协议；\nzh.wikipedia.org，是服务器；\n443，是服务器上的网络端口号；\n/w/index.php，是路径；\n?title=Special:随机页面，是询问。\n\nDNS的作用解析域名\nIP的作用信息传送\n域名域名（Domain names）是互联网基础架构的关键部分。它们为互联网上任何可用的网页服务器提供了方便人类理解的地址。\n域名有三类：国家顶级域名，国际顶级域名，通用顶级域名\n面试题：从输入URL到页面加载发生了什么总结：\n\nDNS解析\nTCP连接\n发送HTTP请求\n服务器处理请求并返回HTTP报文\n浏览器解析渲染页面\n连接结束\n\nHypertext Transfer Protocol (HTTP) 超文本传输协议\n Domain Name System （DNS) 域名解析系统\n"},{"title":"计算机网络","url":"/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"三次握手四次挥手，为什么是三次握手而不是二次握手？客户端与服务端之间通过三次握手建立连接，四次挥手释放连接所谓的三次握手是指建立一个 TCP 连接时，需要客户端和服务器总共发送三个包\n三次握手原理：(1)发送端首先发送一个带有 SYN(synchronize)标志的数据包给接收方(2)接收方接收后，回传一个 SYN/ACK 标志的数据包给发送方传递信息，表示已接收(3)发送端收到接收方回传的数据包，会再次发送一个带有 ACK 标志的包进行确认，表示’握手’接收三次握手的目的是连接服务器指定端口，建立 TCP 连接并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息\n之所以是三次握手，是因为如果只有二次握手，在服务端收到 SYN 后，便向客户端返回一个 ACK 确认就进行 establish 状态，万一这个请求中间出现了网络问题没有发送给客户端，客户端一直处于等待状态，导致后面的信息无法正常接收。\n四次挥手原理：改天再说，暂时不懂 😄\n\nHTTP 的结构"},{"title":"javascript splice","url":"/2021/05/16/JS%20splice/","content":"JavaScript splicesplice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。\n\n"},{"title":"vue中 computed和watch的区别","url":"/2021/05/16/computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"VUE中 computed和watch的区别:flushed:（还需补充）1.翻译computed是计算属性的意思\nwatch是监听的意思\n2.各自描述，可代码举例1.computed不需要加括号\n2.watch有两种选择，一种是immediate 另一种是deep\n"},{"url":"/2021/05/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","content":"\nlayout: 事件循环 event looptitle: loopdate: 2021-05-16 23:21:13tags:\n\n事件循环 event loop宏任务：script , setTimeout, setInterval等微任务: Promise， MutationObserver, queueMicrotaskMutationObserver接口提供了监视对DOM树所做更改的能力过程：1.一开始脚本作为宏任务运行，执行过程以同步代码为主线程\n2.宏任务放到宏任务队列中，微任务放到微任务队列中\n3.当前宏任务执行完出列，检查微任务列表，如果存在微任务，那么依次执行直到全部执行完。\n4.再取一个宏任务，执行，    检查，清空微任务\n5.依次循环\n注意⚠️：在所有任务开始的时候，由于宏任务中包括了script，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如setTimeout)将被放到下一轮宏任务中来执行。\n"}]