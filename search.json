[{"title":"原型和原型链到底是什么东西","url":"/2021/03/02/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/","content":""},{"title":"关于DOM🥱","url":"/2021/04/12/%E5%85%B3%E4%BA%8EDOM/","content":"获取特定元素document.documentElement\n\n获取head元素document.head\n\n获取body元素document.body\n\n获取窗口（窗口不是元素）window\n\n获取所有元素document.all\n\nProperty vs Atteibuteproperty属性JS线程中div1的所有属性，叫做div1的property\nattribute也是属性渲染引擎中div1对应标签的属性，叫做attribute\n区别：大部分时候，同名的property和attribute值相等\n但如果不是标准属性，那么它两只会在一开始时相等\n但注意attribute只支持字符串\n而property支持字符串，布尔等类型\nDOM的增删改查删旧：parentNode.childChile(chileNode)\n新：chileNode.remove()\n改改class: div.className = ‘red blue’(全覆盖)\n改class: div.classList.add(‘red’)\n改style: div.style = ‘width: 100px; color:blue;’\n改style的一部分: div.style.width = ‘200px’\n​            大小写：div.style.backgroundColor=’white’\n改data-*属性：div.dataset.x = ‘frank’\n"},{"title":"JavaScript基本语法","url":"/2021/04/06/JavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"JavaScript的基本语法:sun_with_face:1.什么是表达式和语句二者区别：\n1.表达式一般有值，语句可能有也可能没有2.语句一般会改变环境（声明，赋值）3.:point_up: 上面非绝对:point_up:2.标识符的规则所谓标识符，就是变量，函数，属性或函数参数的名称。标识符可以由一个或多个下列字符组成：第一个字符必须是字母，下划线（_），或美元符号（$）；\n剩下的其他字符可以是字母，下划线，美元符号或数字。\n标识符的字母可以是扩展ASCII中的字母，也可以是Unicode的字母字符。\n3.if else语句if (condition) statement1 else statement2 \n\n如果条件求值为 true，则执行语句 statement1；如果条件求值为 false，则执行语句 statement2。\n4.while for语句while语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此,while循环体内的代码有可能不会执行。for语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式5.break coutinuebreak和coutine语句为执行循环代码提供了更加严格的控制手段。其中，break语句用于立即退出循环，强制执行循环后的下一条语句。而continue语句也用于立即退出循环，但会再次从循环顶部开始执行6.label（标签语句）标签语句用于给语句加标签，语法如下：label: statement\n\n下面是一个例子： start:  for (let i = 0; i &lt; count; i++)&#123;\n console.log(i)\n\n}\n在这个例子中,start是一个标签，可以在后面通过break或continue语句引用。标签语句典型应用场景是嵌套循环"},{"title":"对象增删改查小记😋","url":"/2021/04/07/%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%B0%8F%E8%AE%B0/","content":"JavaScript 对象基本用法对象删除属性delete obj.xxx 或 delete obj[&#39;xxx&#39;]\n\n//即可删除obj的xxx属性 请区分属性值为Undefined和不含属性名\n\n&#39;xxx&#39; in obj === false\n//不含属性名\n\n&#39;XXX&#39; in obj &amp;&amp; obj.XXX === undefined\n//含有属性名，但是值为undefined\n\nobj.xxx === undefined\n//不能断定&#39;xxx&#39; 是否为obj的属性\n\n查询Object.keys(obj)\nconsole.dir(obj)\nobj[&#39;name&#39;]\nobj.name //记住这里的name是字符串\nobj[name] //记住这里的name是变量\n\n改obj[&#39;name&#39;] = &#39;jack&#39; //改自身\nObject.assign(obj,&#123;age:18,...&#125;) //批量改自身\nobj._proto_[&#39;toString&#39;] = &#39;xxx&#39; //改共有属性 不推荐\nObject.prototype[&#39;toString&#39;] = &#39;xxx&#39; //改共有属性\nobj._proto_ = common    //改原型 不推荐\nlet obj = Object.create(common) //改原型\nps:所有的__proto__代码都是强烈不推荐写的\n\n增var obj1 = Object.create(&#123;name : &#39;frank&#39;&#125;) //属性添加在新的原型上\nvar obj2 = new Object(&#123;name : &#39;frank&#39;&#125;) //属性在自身上\n\n"},{"title":"JavaScript执行时机😁","url":"/2021/04/11/JavaScript%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/","content":""},{"title":"计算机网络","url":"/2021/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"三次握手四次挥手，为什么是三次握手而不是二次握手？客户端与服务端之间通过三次握手建立连接，四次挥手释放连接所谓的三次握手是指建立一个 TCP 连接时，需要客户端和服务器总共发送三个包\n三次握手原理：(1)发送端首先发送一个带有 SYN(synchronize)标志的数据包给接收方(2)接收方接收后，回传一个 SYN/ACK 标志的数据包给发送方传递信息，表示已接收(3)发送端收到接收方回传的数据包，会再次发送一个带有 ACK 标志的包进行确认，表示’握手’接收三次握手的目的是连接服务器指定端口，建立 TCP 连接并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息\n之所以是三次握手，是因为如果只有二次握手，在服务端收到 SYN 后，便向客户端返回一个 ACK 确认就进行 establish 状态，万一这个请求中间出现了网络问题没有发送给客户端，客户端一直处于等待状态，导致后面的信息无法正常接收。\n四次挥手原理：改天再说，暂时不懂 😄\n\nHTTP 的结构"},{"title":"数据类型","url":"/2021/03/01/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"JavaScript中什么是基本数据类型什么是引用类型？以及各个数据类型是如何存储的？基本数据类型有：U ARE SO NBU(undefined) S(string symbol) N(null number) B(boolean BigInt)引用类型统称为Object类型细分的话有：Object,array,date,RegExp,Function基本数据类型的数据直接存储在栈中，而引用数据类型是存储在堆中,每个对象在栈地址都会有一个引用地址，引用类型在栈空间都会保存自己的引用地址，以便快速找到堆内存中的对象。栈内存是自动分配内存的。而堆内存是动态分配内存的，不会自动释放，所以每次使用完对象的时候都要将它设置为NULL ,从而减少无用内存的消耗\n\n类型转换在JavaScript中为什么0.2+0.1&gt;0.3?因为在JavaScript中，浮点数是由64位固定长度来表示的，其中1位表示符号位，11位表示指数位，剩下的52位表示尾数位，由于只有52位尾数位，而0.1转为二进制时是0.0001100110011001100…（1100循环）\n\n十进制转二进制方法：这里插入一个地址谢谢！！！由于只能存储52位尾数位，所以便存在精度缺失，把它从内存中取出来转换成十进制就不是原来的0.1了，变成0.10000000…555111。而0.2+0.1是因为0.2和0.1都转换为二进制进行计算，转换为十进制正好是0.30000…004\n\n这时候面试官又会说了 那为什么0.2+0.3=0.5捏？？？嗯？因为0.2和0.3先转化为二进制进行计算，结果是0.10000…001 这时候1的尾数是大于52位，而实际数取值是取52位尾数位的！因此截取后便是0.5\n\n这时候面试官还是那么可爱 又问既然0.1不是0.1了!那为什么输出console.log(0.1)的时候还是0.1呢？这里其实我也不懂,正确答案：在console.log的时候会二进制转换为十进制，十进制会转换为字符串形式，在转换过程中会取近似值，所以打印出来的是一个近似值的字符串！哦耶~\n\n判断数据类型有几种方法？//四种最常用的判断方法：typeof\n缺点：typeof null的值为object 无法分辨是null还是object\n\n\n判断已知对象的方法：instanceof\n缺点：无法判断对象是否存在自己的原型链上\n\n\n根据对象的construct判断：注意：construct在类继承时会出错\n\n\n通用但很繁琐的方法：object.prototype.toString.call()\n\n\n\ninstanceof原理instanceof就是查找目标对象的原型链\n\n为什么typeof null是object这其实是个BUG，因为在JavaScript中，不同对象都是用二进制存储的，如果二进制前三位数为0的话，系统会判断为object类型，而null的前三位数刚好是0，所以也变成了object类型\n\n==  和 ===  有什么区别？===是严格意义上的相等，会比较数据类型和值大小数据类型不同，返回flase数据类型相同，但值大小不同，返回flase\n==是非严格意义上的相等，会比较值的大小数据类型相同，比较值大小数据类型不同，会根据以下表格，再进一步比较。\n    Null == undefined -&gt; true\n    String == Number -&gt; 先将String转换为Number，再比较大小\n    Boolean == Number -&gt; 先将Boolean转换为Number，再比较大小\n    Object == String,Number,Symbol -&gt; Object转换为原始类型\n\n\n手写call，apply，bind本宝宝暂时不会，过两天学完来补上嘻嘻嘻🤭\n字面量创建对象和new创建对象有什么区别，new内部都实现了什么，手写一个new字面量：字面量创建对象更简单，方便阅读不需要作用解析，速度更快\n    let person = &#123;\n        name : &#39;小宇子&#39;,\n        age : &#39;21&#39;,\n        loc : &#39;汕头&#39;,\n        skill : function()&#123;\n            alert(&#39;唱跳RAP&#39;);\n        &#125;\n    &#125;\n    console.log(function.skill());\n\nnew创建对象：创建一个new对象不懂了回去补知识。。。！！！\n\n","tags":["JavaScript"]},{"title":"数据类型小记😁","url":"/2021/04/07/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%8F%E8%AE%B0/","content":"变量声明三种声明方式\nvar a = 1;\nlet a = 1;\nconst a = 1;\na = 1; //错误形式\n\n区别 var 过时 const 声明后必须赋值,且不能修改, 最后声明方式为错误形式\nvar 有变量提升\nname 和 ‘name’的区别一个是变量 一个是字符串\n类型转换number =&gt; string\nString(n)\nn + &#39;&#39;\n&#39;&#39; + n\n\nstring =&gt; number\nNumbers(s)\nparseInt(s) / parseFloat(s)\ns - 0\n\nX =&gt; bool\nBoolean(x)\n!!X\n\nX =&gt; string\nString(x)\nx.toString(x)\n\n\n"},{"title":"HTML入门笔记","url":"/2021/03/02/HTML%E5%85%A5%E9%97%A8/","content":"HTML是李爵士发明的\nHTML起手应该写标签\nHTML的章节标签表示文章/书签标题h1~h6                            \n章节section\n文章article\n段落p\n头部header\n脚部footer\n主要内容main\n旁支内容aside\n划分div\n全局属性class\ncontenteditable\nhidden\nid\nstyle\ntabindex\ntitle\n内容标签ol+li\nul+li\ndl+dt+dd\npre\nhr\na\nem\nstrong\ncode\nquote\nblockquote\n"},{"title":"图解HTTP——第四章  返回结果的HTTP状态码笔记","url":"/2021/03/28/%E5%9B%BE%E8%A7%A3HTTP%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%20%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E7%AC%94%E8%AE%B0/","content":"3.6 内容协商返回最合适的内容内容协商机制是指客户端和服务器端就响应的资源进行协商，提供给客户端最适合的资源\n以响应资源的语音，字符集，编码方式作为判断的基准\n内容协商有三种技术：\n1.服务器驱动协商\n2.客户端驱动协商\n3.透明协商\n4.1 状态码告知从服务器端返回的请求结果1XX 信息性状态码 接受的请求正在处理\n2XX 成功状态码 请求正常处理完毕\n3XX 重定向状态码 需要附加操作以完成请求\n4XX 客户端错误状态码 服务器无法处理请求\n5XX 服务器错误状态码 服务器处理请求出错\n4.2 2XX 成功2XX 的响应结果表明请求被正常处理\n4.2.1 200 OK表示客户端发来的请求被服务器端正常处理\n4.2.2 204 No Content表示客户端发来的请求被服务器正常处理，但是请求无资源返回\n4.2.3 206 Partial Content表示客户端进行了范围请求，服务器端正常处理了这部分的 GET 请求\n4.3 3XX 重定向3XX 的响应结果表明浏览器需要执行某些特殊的处理来正确处理请求\n4.3.1 301 Move Permanently永久性重定向\n4.3.2 302临时重定向\n4.3.3 303 See other"},{"title":"CSS小结","url":"/2021/04/25/CSS%E5%B0%8F%E7%BB%93/","content":"CSS定位布局是屏幕平面上的，定位是垂直于屏幕的\n(https://zellwk.com/images/2014/02/box-sizing.jpg)\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/position position参考\n"},{"title":"HTTP缓存的意义","url":"/2021/04/25/HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89/","content":"HTTP缓存的意义https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching 原文链接\n通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用HTTP缓存，变得更加响应性。\n不同种类的缓存缓存的种类有很多，大致分为两类：私有与共享缓存。共存缓存存储的响应能被多个用户使用。私有缓存只能用于单独用户。\n私有（浏览器缓存）共享（代理缓存）缓存操作的目标常见的HTTP缓存只能存储”GET”响应\n成功响应状态码：200 一个成功获取HTML文档，图片，或者文件的响应。\n永久重定向状态码：301\n错误响应状态码：404\n不完全响应状态码：206（只返回局部的信息）\n缓存控制（Cache-control头）没有缓存Cache-Control: no-store\n\n缓存但重新验证Cache-Control: no-cache\n\n私有和公共缓存Cache-Control: private\nCache-Control: public\n\n过期Cache-Control: max-age=31536000\n\n验证方式Cache-Control: must-revalidate\n\nPragma头Pragma 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。\n"},{"title":"webpack中 loader和plugin的区别","url":"/2021/04/25/webpack%E4%B8%AD%20loader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"webpack中 loader和plugin的区别\nloader 加载器 用来加载文件 加载JS/CSS/IMG 文件\nplugin 插件 用来扩展功能   加强webpack功能 HtmlWebpackPlugin用来生成一个HTML文件     MiniCssExtractPlugin 用来抽取CSS文件生成一个文件\n"},{"title":"关于HTML盒模型","url":"/2021/04/25/%E5%85%B3%E4%BA%8EHTML%E7%9B%92%E6%A8%A1%E5%9E%8B/","content":"CSS的盒模型分两种，一种content盒模型   一种是border盒模型\ncontent 的宽度只包含content内容\nborder的宽度包含border padding content\nCSS调试时可使用border 也可使用outline outline不计边框元素\n"}]